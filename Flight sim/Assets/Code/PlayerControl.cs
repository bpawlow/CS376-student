using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// Control code for the the player's game object.
/// Very approximate simulation of flight dynamics.
/// </summary>
public class PlayerControl : MonoBehaviour {
    /// <summary>
    /// Coefficient of draft for head winds
    /// </summary>
    [Header("Aerodynamic coefficients")]
    public float ForwardDragCoefficient = 0.01f;
    /// <summary>
    /// Drag coefficient for winds blowing up/down across wings
    /// </summary>
    public float VerticalDragCoefficient = 0.5f;
    /// <summary>
    /// Lift generated by the wings
    /// </summary>
    public float LiftCoefficient = 0.01f;

    /// <summary>
    /// How far the plane can tilt around the X axis
    /// </summary>
    [Header("Movement Speeds")]
    public float PitchRange = 45f;
    /// <summary>
    /// How far the plane can rotate about the Z axis
    /// </summary>
    public float RollRange = 45;
    /// <summary>
    /// How fast the plane yaws for a given degree of roll.
    /// </summary>
    public float RotationalSpeed = 5f;
    /// <summary>
    /// Thrust generated when the throttle is pulled back all the way.
    /// </summary>
    public float MaximumThrust = 20f;

    /// <summary>
    /// Text element for displaying status information
    /// </summary>
    [Header("HUD")]
    public Text StatusDisplay;
    /// <summary>
    /// Text element for displaying game-over text
    /// </summary>
    public Text GameOverText;

    /// <summary>
    /// Cached copy of the player's RigidBody component
    /// </summary>
    private Rigidbody playerRB;


    /// <summary>
    /// Magic layer mask code for the updraft(s)
    /// </summary>
    const int UpdraftLayerMask = 1 << 8;


    #region Internal flight state
    /// <summary>
    /// Current yaw (rotation about the Y axis)
    /// </summary>
    private float yaw;
    /// <summary>
    /// Current pitch (rotation about the X axis)
    /// </summary>
    private float pitch;
    /// <summary>
    /// Current roll (rotation about the Z axis)
    /// </summary>
    private float roll;
    /// <summary>
    /// Current thrust (forward force provided by engines
    /// </summary>
    private float thrust;
#endregion

    /// <summary>
    /// Initialize component
    /// </summary>
    internal void Start() {
        playerRB = GetComponent<Rigidbody>();
        playerRB.velocity = transform.forward*3;
        roll = 0;
        pitch = 0;
        yaw = 0;
    }

    internal void FixedUpdate()

    {
        roll = Mathf.Lerp(roll, Input.GetAxis("Horizontal") * RollRange, 0.01f);
        pitch = Mathf.Lerp(pitch, Input.GetAxis("Vertical") * PitchRange, 0.01f);
        yaw += roll * RotationalSpeed * Time.fixedDeltaTime;

        //input Mathlerp// 

        playerRB.MoveRotation(Quaternion.Euler(pitch, yaw, roll));

        var thrustVal = Input.GetAxis("Thrust");

        if (thrustVal < 0f)
        {
            thrustVal = 0f;
        }

        thrust = thrustVal * MaximumThrust;

        playerRB.AddForce(transform.forward * thrust);

        var v_rel = -playerRB.velocity;

        //Uplift

        var array_colliders = Physics.OverlapSphere(transform.localPosition, 1f, UpdraftLayerMask);

        if (array_colliders != null && array_colliders.Length != 0)
        {
            //Debug.Log(Physics.OverlapSphere(transform.localPosition, 1f, UpdraftLayerMask));
            v_rel = GameObject.Find("Updraft").GetComponent<Updraft>().WindVelocity - playerRB.velocity; 
        }

        //lift 
        var v_f = Vector3.Dot(v_rel, transform.forward);
        ///Vector3 lift = new Vector3(0, 0, 0); 
        var lift = LiftCoefficient * Mathf.Pow(v_f, 2) * transform.up;

        //forward drag 
        var forw_drag = ForwardDragCoefficient * Mathf.Pow(v_f, 2) * transform.forward;

        if (v_f < 0)
        {
            forw_drag = -1 * forw_drag;
        }

        // Vertical drag 
        var v_up = Vector3.Dot(v_rel, transform.up);

        var vert_drag = VerticalDragCoefficient * Mathf.Pow(v_up, 2) * transform.up;

        if (v_up < 0)
        {
            vert_drag = -1 * vert_drag;
        }

        //final addition of forces
        var final_drag = forw_drag + vert_drag;
        playerRB.AddForce(lift);
        playerRB.AddForce(final_drag);
    }

    void OnCollisionEnter(Collision collision)
    {
        bool landed = false; 
        if (collision.gameObject.name == "LandingPlatform")
        {
            //Debug.Log(collision.relativeVelocity.magnitude);
            if (collision.relativeVelocity.magnitude <= GameObject.Find("LandingPlatform").GetComponent<LandingPlatform>().MaxLandingSpeed)
            {
                landed = true;
                OnGameOver(landed);
            }
            else
            {
                OnGameOver(landed);
            }
        }
        else
        {
            OnGameOver(landed);
        }
    }
        /// <summary>
        /// Show game-over display
        /// </summary>
        /// <param name="safe">True if we won, false if we crashed</param>
    private void OnGameOver(bool safe) {
        playerRB.velocity = Vector3.zero;
        playerRB.useGravity = false;
        playerRB.constraints = RigidbodyConstraints.FreezeAll;
        if (safe) {
            GameOverText.text = "You Win!";
        } else {
            GameOverText.text = "OOPS";
        }
    }

    /// <summary>
    /// Display status information
    /// </summary>
    internal void OnGUI()
    {
        StatusDisplay.text = string.Format("Speed: {0:00.00}    altitude: {1:00.00}    Thrust {2:0.0}",
            playerRB.velocity.magnitude,
            transform.position.y,
            thrust);
    }
}
